
# Phase 1: Foundation (Week 1-2)

## 🎯 Learning Objectives

By the end of this phase, you will understand:

- TypeScript fundamentals and best practices
- Express.js server architecture
- MongoDB connection and basic operations
- Project structure and development workflow

## 📚 Day 1-2: TypeScript Fundamentals

### What is TypeScript?

TypeScript is a superset of JavaScript that adds static typing. It helps catch errors at compile time rather than runtime.

**Key Benefits:**

- **Type Safety**: Prevents common JavaScript errors
- **Better IDE Support**: Autocomplete, refactoring, navigation
- **Self-Documenting Code**: Types serve as documentation
- **Easier Refactoring**: Safe code changes with confidence

### Basic TypeScript Concepts

#### 1. Type Annotations

```typescript
// Basic types
let name: string = 'John'
let age: number = 30
let isActive: boolean = true
let hobbies: string[] = ['reading', 'coding']
let user: {name: string; age: number} = {name: 'John', age: 30}

// Function types
function greet(name: string): string {
     return `Hello, ${name}!`
}

// Arrow functions
const multiply = (a: number, b: number): number => a * b
```

#### 2. Interfaces

Interfaces define the shape of objects:

```typescript
interface User {
     id: number
     name: string
     email: string
     isActive?: boolean // Optional property
}

function createUser(userData: User): User {
     return {
          id: Date.now(),
          name: userData.name,
          email: userData.email,
          isActive: userData.isActive ?? true,
     }
}
```

#### 3. Enums

Enums define a set of named constants:

```typescript
enum UserRole {
     USER = 'user',
     ADMIN = 'admin',
     MODERATOR = 'moderator',
}

interface User {
     role: UserRole
}
```

#### 4. Generics

Generics allow you to create reusable components:

```typescript
interface ApiResponse<T> {
     success: boolean
     data: T
     message?: string
}

function fetchUser(id: number): Promise<ApiResponse<User>> {
     // Implementation
}
```

### TypeScript Configuration

Our `tsconfig.json` uses strict settings:

```json
{
     "strict": true, // Enable all strict checks
     "noImplicitAny": true, // No implicit any types
     "noImplicitReturns": true, // Functions must return values
     "noUnusedLocals": true, // No unused variables
     "exactOptionalPropertyTypes": true // Exact optional property types
}
```

## 📚 Day 3-4: Express.js Basics

### What is Express.js?

Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.

**Key Features:**

- **Routing**: Handle different HTTP methods and URLs
- **Middleware**: Functions that have access to request/response objects
- **Static Files**: Serve static files like images, CSS, JavaScript
- **Template Engines**: Render dynamic HTML pages

### Express.js Architecture

#### 1. Basic Server Setup

```typescript
import express from 'express'

const app = express()
const port = 3001

// Middleware
app.use(express.json())

// Routes
app.get('/', (req, res) => {
     res.json({message: 'Hello World!'})
})

app.listen(port, () => {
     console.log(`Server running on port ${port}`)
})
```

#### 2. Middleware Pattern

Middleware functions are executed sequentially:

```typescript
// Custom middleware
const logger = (req: Request, res: Response, next: NextFunction) => {
     console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`)
     next() // Call next middleware
}

// Apply middleware
app.use(logger)
```

#### 3. Route Organization

```typescript
// routes/users.ts
import {Router} from 'express'

const router = Router()

router.get('/', async (req, res) => {
     // Get all users
})

router.post('/', async (req, res) => {
     // Create user
})

export default router

// app.ts
import userRoutes from './routes/users'
app.use('/api/users', userRoutes)
```

### Security Middleware

#### 1. Helmet

Helmet helps secure Express apps by setting various HTTP headers:

```typescript
import helmet from 'helmet'

app.use(
     helmet({
          contentSecurityPolicy: {
               directives: {
                    defaultSrc: ["'self'"],
                    styleSrc: ["'self'", "'unsafe-inline'"],
               },
          },
     }),
)
```

#### 2. CORS

Cross-Origin Resource Sharing configuration:

```typescript
import cors from 'cors'

app.use(
     cors({
          origin: 'http://localhost:3000',
          credentials: true,
     }),
)
```

#### 3. Rate Limiting

Prevent abuse with rate limiting:

```typescript
import rateLimit from 'express-rate-limit'

const limiter = rateLimit({
     windowMs: 15 * 60 * 1000, // 15 minutes
     max: 100, // limit each IP to 100 requests per windowMs
})

app.use(limiter)
```

## 📚 Day 5-6: Database Connections

### MongoDB with Mongoose

MongoDB is a NoSQL document database, and Mongoose is an Object Data Modeling (ODM) library.

#### 1. Connection Setup

```typescript
import mongoose from 'mongoose'

const connectDB = async (): Promise<void> => {
     try {
          await mongoose.connect('mongodb://localhost:27017/myapp')
          console.log('MongoDB connected')
     } catch (error) {
          console.error('MongoDB connection error:', error)
          process.exit(1)
     }
}
```

#### 2. Schema Definition

```typescript
import {Schema, model} from 'mongoose'

const userSchema = new Schema(
     {
          name: {
               type: String,
               required: true,
               trim: true,
          },
          email: {
               type: String,
               required: true,
               unique: true,
               lowercase: true,
          },
          age: {
               type: Number,
               min: 0,
          },
     },
     {
          timestamps: true, // Adds createdAt and updatedAt
     },
)

export const User = model('User', userSchema)
```

#### 3. Basic CRUD Operations

```typescript
// Create
const user = new User({name: 'John', email: 'john@example.com'})
await user.save()

// Read
const users = await User.find({age: {$gte: 18}})
const user = await User.findById(userId)

// Update
await User.findByIdAndUpdate(userId, {age: 25})

// Delete
await User.findByIdAndDelete(userId)
```

### Redis for Caching

Redis is an in-memory data structure store used for caching and session management.

#### 1. Connection Setup

```typescript
import {createClient} from 'redis'

const client = createClient({
     url: 'redis://localhost:6379',
})

await client.connect()
```

#### 2. Basic Operations

```typescript
// Set and get
await client.set('key', 'value')
const value = await client.get('key')

// Set with expiration
await client.setEx('key', 3600, 'value') // Expires in 1 hour

// Delete
await client.del('key')

// Check if exists
const exists = await client.exists('key')
```

## 📚 Day 7-8: Project Structure & Best Practices

### Project Organization

```
backend/
├── src/
│   ├── config/          # Configuration files
│   ├── controllers/     # Route handlers
│   ├── middleware/      # Custom middleware
│   ├── models/          # Database models
│   ├── routes/          # API routes
│   ├── services/        # Business logic
│   ├── types/           # TypeScript types
│   ├── utils/           # Utility functions
│   └── index.ts         # Main server file
```

### Best Practices

#### 1. Error Handling

```typescript
// Custom error class
class AppError extends Error {
     public statusCode: number
     public isOperational: boolean

     constructor(message: string, statusCode: number) {
          super(message)
          this.statusCode = statusCode
          this.isOperational = true
     }
}

// Error handling middleware
const errorHandler = (
     error: Error,
     req: Request,
     res: Response,
     next: NextFunction,
) => {
     if (error instanceof AppError) {
          res.status(error.statusCode).json({
               success: false,
               error: error.message,
          })
     } else {
          res.status(500).json({
               success: false,
               error: 'Internal server error',
          })
     }
}
```

#### 2. Async/Await Pattern

```typescript
// Good: Using async/await
const getUser = async (req: Request, res: Response) => {
     try {
          const user = await User.findById(req.params.id)
          if (!user) {
               throw new AppError('User not found', 404)
          }
          res.json({success: true, data: user})
     } catch (error) {
          next(error)
     }
}

// Avoid: Callback hell
const getUser = (req: Request, res: Response) => {
     User.findById(req.params.id, (error, user) => {
          if (error) {
               return res.status(500).json({error: error.message})
          }
          if (!user) {
               return res.status(404).json({error: 'User not found'})
          }
          res.json({success: true, data: user})
     })
}
```

#### 3. Environment Variables

```typescript
import dotenv from 'dotenv'

dotenv.config()

const config = {
     port: process.env.PORT || 3001,
     mongoUri: process.env.MONGODB_URI || 'mongodb://localhost:27017/myapp',
     jwtSecret: process.env.JWT_SECRET || 'default-secret',
}
```

## 🧪 Practical Exercises

### Exercise 1: TypeScript Basics

Create a simple calculator with TypeScript:

```typescript
interface Calculator {
     add(a: number, b: number): number
     subtract(a: number, b: number): number
     multiply(a: number, b: number): number
     divide(a: number, b: number): number
}

class SimpleCalculator implements Calculator {
     add(a: number, b: number): number {
          return a + b
     }

     subtract(a: number, b: number): number {
          return a - b
     }

     multiply(a: number, b: number): number {
          return a * b
     }

     divide(a: number, b: number): number {
          if (b === 0) {
               throw new Error('Division by zero')
          }
          return a / b
     }
}
```

### Exercise 2: Express Route

Create a simple API endpoint:

```typescript
// GET /api/hello/:name
app.get('/api/hello/:name', (req: Request, res: Response) => {
     const {name} = req.params
     res.json({
          message: `Hello, ${name}!`,
          timestamp: new Date().toISOString(),
     })
})

// POST /api/users
app.post('/api/users', async (req: Request, res: Response) => {
     try {
          const user = new User(req.body)
          await user.save()
          res.status(201).json({
               success: true,
               data: user,
          })
     } catch (error) {
          res.status(400).json({
               success: false,
               error: error.message,
          })
     }
})
```

### Exercise 3: Database Operations

Create a simple user management system:

```typescript
// Create user
const createUser = async (userData: Partial<User>) => {
     const user = new User(userData)
     return await user.save()
}

// Get all users
const getAllUsers = async () => {
     return await User.find({isActive: true})
}

// Update user
const updateUser = async (id: string, updates: Partial<User>) => {
     return await User.findByIdAndUpdate(id, updates, {new: true})
}

// Delete user
const deleteUser = async (id: string) => {
     return await User.findByIdAndDelete(id)
}
```

## 📝 Key Takeaways

1. **TypeScript** provides type safety and better developer experience
2. **Express.js** is a flexible web framework with middleware support
3. **MongoDB** is a document database that works well with JavaScript/TypeScript
4. **Redis** is useful for caching and session management
5. **Project structure** should be organized by features
6. **Error handling** should be consistent throughout the application
7. **Environment variables** keep configuration separate from code
8. **Async/await** makes asynchronous code more readable

## 🔗 Next Steps

In Phase 2, we'll build upon this foundation to create:

- Authentication and authorization
- Input validation
- Advanced Express.js features
- API documentation

## 🧪 Additional Practical Exercises

### Exercise 4: TypeScript Advanced Types

Practice with utility types and advanced TypeScript features:

```typescript
// Utility types example
interface User {
     id: number
     name: string
     email: string
     password: string
     createdAt: Date
     updatedAt: Date
}

// Omit utility type - exclude password from public user
type PublicUser = Omit<User, 'password'>

// Pick utility type - only select specific fields
type UserSummary = Pick<User, 'id' | 'name' | 'email'>

// Partial utility type - make all properties optional
type UserUpdate = Partial<User>

// Record utility type - create object with specific keys
type UserRoles = Record<string, 'admin' | 'user' | 'moderator'>

// Function to transform user data
function createPublicUser(user: User): PublicUser {
     const {password, ...publicUser} = user
     return publicUser
}
```

### Exercise 5: Express.js Middleware Chain

Create a custom middleware chain:

```typescript
// Custom middleware for logging
const requestLogger = (req: Request, res: Response, next: NextFunction) => {
     console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`)
     next()
}

// Custom middleware for timing
const requestTimer = (req: Request, res: Response, next: NextFunction) => {
     const start = Date.now()
     res.on('finish', () => {
          const duration = Date.now() - start
          console.log(`${req.method} ${req.path} - ${duration}ms`)
     })
     next()
}

// Custom middleware for authentication check
const requireAuth = (req: Request, res: Response, next: NextFunction) => {
     const token = req.headers.authorization?.split(' ')[1]

     if (!token) {
          return res.status(401).json({error: 'Authentication required'})
     }

     // Verify token logic here
     req.user = {id: 1, name: 'John'} // Mock user
     next()
}

// Apply middleware chain
app.use(requestLogger)
app.use(requestTimer)

// Protected routes
app.get('/api/profile', requireAuth, (req: Request, res: Response) => {
     res.json({user: req.user})
})
```

### Exercise 6: MongoDB Aggregation Pipeline

Practice with MongoDB aggregation:

```typescript
// Complex user analytics query
const getUserAnalytics = async () => {
     const analytics = await User.aggregate([
          // Match active users
          {$match: {isActive: true}},

          // Group by role
          {
               $group: {
                    _id: '$role',
                    count: {$sum: 1},
                    avgAge: {$avg: '$age'},
               },
          },

          // Sort by count
          {$sort: {count: -1}},

          // Project final format
          {
               $project: {
                    role: '$_id',
                    userCount: '$count',
                    averageAge: {$round: ['$avgAge', 2]},
               },
          },
     ])

     return analytics
}

// Usage
const analytics = await getUserAnalytics()
console.log(analytics)
// Output: [
//   { role: 'user', userCount: 150, averageAge: 28.5 },
//   { role: 'admin', userCount: 5, averageAge: 32.2 }
// ]
```

### Exercise 7: Redis Caching Strategy

Implement a caching strategy with Redis:

```typescript
// Cache service
class CacheService {
     private redis: RedisClientType

     constructor(redis: RedisClientType) {
          this.redis = redis
     }

     // Cache user data
     async cacheUser(userId: string, userData: any, ttl: number = 3600) {
          const key = `user:${userId}`
          await this.redis.setEx(key, ttl, JSON.stringify(userData))
     }

     // Get cached user data
     async getCachedUser(userId: string) {
          const key = `user:${userId}`
          const data = await this.redis.get(key)
          return data ? JSON.parse(data) : null
     }

     // Invalidate cache
     async invalidateUser(userId: string) {
          const key = `user:${userId}`
          await this.redis.del(key)
     }

     // Cache with pattern
     async cacheWithPattern(pattern: string, data: any, ttl: number = 3600) {
          const key = `cache:${pattern}:${Date.now()}`
          await this.redis.setEx(key, ttl, JSON.stringify(data))
          return key
     }
}

// Usage in controller
const getUserWithCache = async (req: Request, res: Response) => {
     const {id} = req.params
     const cacheService = new CacheService(redisClient)

     // Try to get from cache first
     let user = await cacheService.getCachedUser(id)

     if (!user) {
          // Get from database
          user = await User.findById(id)

          if (user) {
               // Cache for 1 hour
               await cacheService.cacheUser(id, user, 3600)
          }
     }

     if (!user) {
          return res.status(404).json({error: 'User not found'})
     }

     res.json({user})
}
```

## 🎯 Mini-Projects for Phase 1

### Project 1: Simple Calculator API (Day 2-3)

**Goal:** Create a basic Express.js API with TypeScript

**Requirements:**
- Create calculator endpoints (add, subtract, multiply, divide)
- Use TypeScript interfaces for request/response
- Implement error handling for division by zero
- Add input validation

**Learning Outcomes:**
- TypeScript types and interfaces
- Express.js routing
- Error handling patterns
- Input validation

### Project 2: User Management System (Day 5-6)

**Goal:** Build a simple user CRUD system

**Requirements:**
- Create User model with Mongoose
- Implement CRUD operations (Create, Read, Update, Delete)
- Add basic validation
- Use Redis for caching user data

**Learning Outcomes:**
- MongoDB with Mongoose
- Schema design
- CRUD operations
- Redis caching

### Project 3: Weather API Integration (Day 7-8)

**Goal:** Integrate with external API and apply best practices

**Requirements:**
- Create weather API client
- Implement caching with Redis
- Add proper error handling
- Use environment variables
- Add logging

**Learning Outcomes:**
- External API integration
- Caching strategies
- Environment configuration
- Logging and debugging

## 📚 Additional Resources

- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Express.js Guide](https://expressjs.com/en/guide/routing.html)
- [Mongoose Documentation](https://mongoosejs.com/docs/)
- [Redis Documentation](https://redis.io/documentation)
- [TypeScript Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
- [MongoDB Aggregation](https://docs.mongodb.com/manual/aggregation/)
- [Redis Patterns](https://redis.io/topics/patterns)

- [MongoDB Aggregation](https://docs.mongodb.com/manual/aggregation/)
- [Redis Patterns](https://redis.io/topics/patterns)
